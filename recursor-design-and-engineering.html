<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8. Design and Engineering of the PowerDNS Recursor</title><link rel="stylesheet" href="docbook.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /><link rel="home" href="index.html" title="PowerDNS manual" /><link rel="up" href="built-in-recursor.html" title="Chapter 16. PowerDNS Recursor: a high performance resolving nameserver" /><link rel="prev" href="recursor-scripting.html" title="7. Scripting" /><link rel="next" href="replication.html" title="Chapter 17. Master/Slave operation &amp; replication" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">8. Design and Engineering of the PowerDNS Recursor</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="recursor-scripting.html">Prev</a> </td><th width="60%" align="center">Chapter 16. PowerDNS Recursor: a high performance resolving nameserver</th><td width="20%" align="right"> <a accesskey="n" href="replication.html">Next</a></td></tr></table><hr /></div><div class="sect1" title="8. Design and Engineering of the PowerDNS Recursor"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="recursor-design-and-engineering"></a>8. Design and Engineering of the PowerDNS Recursor</h2></div></div></div><div class="toc"><dl><dt><span class="sect2"><a href="recursor-design-and-engineering.html#id410502">8.1. The PowerDNS Recursor</a></span></dt><dt><span class="sect2"><a href="recursor-design-and-engineering.html#id410515">8.2. Synchronous code using MTasker</a></span></dt><dt><span class="sect2"><a href="recursor-design-and-engineering.html#id410588">8.3. MPlexer</a></span></dt><dt><span class="sect2"><a href="recursor-design-and-engineering.html#id410681">8.4. MOADNSParser</a></span></dt><dt><span class="sect2"><a href="recursor-design-and-engineering.html#id410878">8.5. The C++ Standard Library / Boost</a></span></dt><dt><span class="sect2"><a href="recursor-design-and-engineering.html#id410920">8.6. Actual DNS Algorithm</a></span></dt><dt><span class="sect2"><a href="recursor-design-and-engineering.html#id411069">8.7. The non-cached case</a></span></dt><dt><span class="sect2"><a href="recursor-design-and-engineering.html#id411340">8.8. Some of the things we glossed over</a></span></dt><dt><span class="sect2"><a href="recursor-design-and-engineering.html#id411394">8.9. The Recursor Cache</a></span></dt><dt><span class="sect2"><a href="recursor-design-and-engineering.html#id411488">8.10. Some small things</a></span></dt></dl></div><p>
	</p><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="warning.png" /></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>
	    This section is aimed at programmers wanting to contibute to the recursor, or to help fix bugs. It is not required
	    reading for a PowerDNS operator, although it might prove interesting.
	  </p></td></tr></table></div><p>
      </p><p>The PowerDNS Recursor consists of very little code, the core DNS logic is less than a thousand lines.</p><p>This smallness is achieved through the use of some fine infrastructure: MTasker, MOADNSParser, MPlexer and the C++ Standard Library/Boost. This page will explain the conceptual relation between these components, and the route of a packet through the program.</p><div class="sect2" title="8.1. The PowerDNS Recursor"><div class="titlepage"><div><div><h3 class="title"><a id="id410502"></a>8.1. The PowerDNS Recursor</h3></div></div></div><p>The Recursor started out as a tiny project, mostly a technology demonstration. These days it  consists of the core plus 9000 lines of features. This combined with a need for very high performance has made the recursor code less accessible than it was. The page you are reading hopes to rectify this situation.</p></div><div class="sect2" title="8.2. Synchronous code using MTasker"><div class="titlepage"><div><div><h3 class="title"><a id="id410515"></a>8.2. Synchronous code using MTasker</h3></div></div></div><p>The original name of the program was <span class="command"><strong>syncres</strong></span>, which is still reflected in the filename <code class="literal">syncres.cc</code>, and the class SyncRes. This means that PowerDNS is written naively, with one thread of execution per query, synchronously waiting for packets, Normally this would lead to very bad performance (unless running on a computer with very fast threading, like possibly the Sun CoolThreads family), so PowerDNS employs <a class="ulink" href="http://ds9a.nl/mtasker" target="_top">MTasker</a> for very fast userspace threading.</p><p>MTasker, which was developed separately from PowerDNS, does not provide a full multithreading system but restricts itself to those features a nameserver needs. It offers cooperative multitasking, which means there is no forced preemption of threads. This in turn means that no two <span class="command"><strong>MThreads</strong></span> ever really run at the same time.</p><p>This is both good and bad, but mostly good. It means PowerDNS does not have to think about locking. No two threads will ever be talking to the DNS cache at the same time, for example.</p><p>It also means that the recursor could block if any operation takes too long.</p><p>The core interaction with MTasker are the waitEvent() and sendEvent() functions. These pass around PacketID objects. Everything PowerDNS needs to wait for is described by a PacketID event, so the name is a bit misleading. Waiting for a TCP socket to have data available is also passed via a PacketID, for example.</p><p>The version of MTasker in PowerDNS is newer than that described at the MTasker site, with a vital difference being that thet waitEvent() structure passes along a copy of the exact PacketID sendEvent() transmitted. Furthermore, threads can trawl through the list of events being waited for and modify the respective PacketIDs. This is used for example with <span class="command"><strong>near miss</strong></span> packets: packets that appear to answer questions we asked, but differ in the DNS id. On seeing such a packet, the recursor trawls through all PacketIDs and if it finds any nearmisses, it updates the PacketID::nearMisses counter. The actual PacketID thus lives inside MTasker while any thread is waiting for it.</p></div><div class="sect2" title="8.3. MPlexer"><div class="titlepage"><div><div><h3 class="title"><a id="id410588"></a>8.3. MPlexer</h3></div></div></div><p>The Recursor uses a separate socket per outgoing query. This has the important benefit of making spoofing 64000 times harder, and additionally means that ICMP errors are reported back to the program. In measurements this appears to happen to one in ten queries, which would otherwise take a two-second timeout before PowerDNS moves on to another nameserver.</p><p>However, this means that the program routinely needs to wait on hundreds or even thousands of sockets. Different operating systems offer various ways to monitor the state of sockets or more generally, filedescriptors. To abstract out the differing strategies (<code class="function">select</code>, <code class="function">epoll</code>, <code class="function">kqueue</code>, <code class="function">completion ports</code>), PowerDNS contains <span class="command"><strong>MPlexer</strong></span> classes, all of which descend from the FDMultiplexer class.</p><p>This class is very simple and offers only five important methods: addReadFD(), addWriteFD(), removeReadFD(), removeWriteFD() and run.</p><p>The arguments to the <span class="command"><strong>add</strong></span> functions consist of an fd, a callback, and a boost::any variable that is passed as a reference to the callback.</p><p>This might remind you of the MTasker above, and it is indeed the same trick: state is stored within the MPlexer. As long as a filedescriptor remains within either the Read or Write active list, its state will remain stored.</p><p>On arrival of a packet (or more generally, when an FD becomes readable or writable, which for example might mean a new TCP connection), the callback is called with the aforementioned reference to its parameter.</p><p>The callback is free to call removeReadFD() or removeWriteFD() to remove itself from the active list.</p><p>PowerDNS defines such callbacks as newUDPQuestion(), newTCPConnection(), handleRunningTCPConnection().</p><p>Finally, the run() method needs to be called whenever the program is ready for new data. This happens in the main loop in pdns_recursor.cc. This loop is what MTasker refers to as <span class="command"><strong>the kernel</strong></span>. In this loop, any packets or other MPlexer events get translated either into new MThreads within MTasker, or into calls to sendEvent(), which in turn wakes up other MThreads.</p></div><div class="sect2" title="8.4. MOADNSParser"><div class="titlepage"><div><div><h3 class="title"><a id="id410681"></a>8.4. MOADNSParser</h3></div></div></div><p>Yes, this does stand for <span class="command"><strong>the Mother of All DNS Parsers</strong></span>. And even that name does not do it justice! The MOADNSParser is the third attempt I've made at writing DNS packet parser and after two miserable failures, I think I've finally gotten it right.</p><p>Writing and parsing DNS packets, and the DNS records it contains, consists of four things:
	  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
		Parsing a DNS record (from packet) into memory
	      </p></li><li class="listitem"><p>
		Generating a DNS record from memory (to packet)
	      </p></li><li class="listitem"><p>
		Writing out memory to user-readable zone format
	      </p></li><li class="listitem"><p>
		Reading said zone format into memory
	      </p></li></ol></div><p>
	</p><p>This gets tedious very quickly, as one needs to implement all four operations for each new record type, and there are dozens of them.</p><p>While writing the MOADNSParser, it was discovered there is a remarkable symmetry between these four transitions. DNS Records are nearly always laid out in the same order in memory as in their zone format representation. And reading is nothing but inverse writing.</p><p>So, the MOADNSParser is built around the notion of a <span class="command"><strong>Conversion</strong></span>, and we write all Conversion types once. So we have a Conversion from IP address in memory to an IP address in a DNS packet, and vice versa. And we have a Conversion from an IP address in zone format to memory, and vice versa.</p><p>This in turn means that the entire implementation of the ARecordContent is as follows (wait for it!)</p><pre class="literallayout">conv.xfrIP(d_ip);</pre><p>Through the use of the magic called <code class="literal">c++ Templates</code>, this one line does everything needed to perform the four operations mentioned above.</p><p>At one point, I got really obsessed with PowerDNS memory use. So, how do we store DNS data in the PowerDNS recorsor? I mentioned <span class="command"><strong>memory</strong></span> above a lot - this means we could just store the DNSRecordContent objects. However, this would be wasteful.</p><p>For example, storing the following:</p><pre class="literallayout">www.ds9a.nl  3600 IN   CNAME  outpost.ds9a.nl.</pre><p>Would duplicate a lot of data. So, what is actually stored is a partial DNS packet. To store the CNAMEDNSRecordContent that corresponds to the above, we generate a DNS packet that has <span class="command"><strong>www.ds9a.nl IN CNAME</strong></span> as its question. Then we add <span class="command"><strong>3600 IN CNAME outpost.ds9a.nl</strong></span>. as its answer. Then we chop off the question part, and store the rest in the <span class="command"><strong>www.ds9a.nl IN CNAME</strong></span> key in our cache.</p><p>When we need to retrieve <span class="command"><strong>www.ds9a.nl IN CNAME</strong></span>, the inverse happens. We find the proper partial packet, prefix it with a question for <span class="command"><strong>www.ds9a.nl IN CNAME</strong></span>, and expand the resulting packet into the answer <span class="command"><strong>3600 IN CNAME outpost.ds9a.nl.</strong></span>.</p><p>Why do we go through all these motions? Because of DNS compression, which allows us to omit the whole <span class="command"><strong>.ds9a.nl.</strong></span> part, saving us 9 bytes. This is amplified when storing multiple MX records which all look more or less alike. This optimization is not performed yet though.</p><p>Even without compression, it makes sense as all records are automatically stored very compactly.</p><p>The PowerDNS recursor only parses a number of <span class="command"><strong>well known record types</strong></span> and passes all other information across verbatim - it doesn't have to know about the content it is serving.</p></div><div class="sect2" title="8.5. The C++ Standard Library / Boost"><div class="titlepage"><div><div><h3 class="title"><a id="id410878"></a>8.5. The C++ Standard Library / Boost</h3></div></div></div><p>C++ is a powerful language. Perhaps a bit too powerful at times, you can turn a program into a real freakshow if you so desire.</p><p>PowerDNS generally tries not to go overboard in this respect, but we do build upon a very advanced part of the <a class="ulink" href="http://www.boost.org" target="_top">Boost</a> C++ library: 
	  <a class="ulink" href="http://boost.org/libs/multi_index/doc/index.html" target="_top">boost::multi index container</a>.</p><p>This container provides the equivalent of SQL indexes on multiple keys. It also implements compound keys, which PowerDNS uses as well.</p><p>The main DNS cache is implemented as a multi index container object, with a compound key on the name and type of a record. Furthermore, the cache is sequenced, each time a record is accessed it is moved to the end of the list. When cleanup is performed, we start at the beginning. New records also get inserted at the end. For DNS correctness, the sort order of the cache is case insensitive.</p><p>The multi index container appears in other parts of PowerDNS, and MTasker as well.</p></div><div class="sect2" title="8.6. Actual DNS Algorithm"><div class="titlepage"><div><div><h3 class="title"><a id="id410920"></a>8.6. Actual DNS Algorithm</h3></div></div></div><p>The DNS rfcs do define the DNS algorithm, but you can't actually implement it exactly that way, it was written in 1987.</p><p>Also, like what happened to HTML, it is expected that even non-standards conforming domains work, and a sizeable fraction of them is misconfigured these days.</p><p>Everything begins with SyncRes::beginResolve(), which knows nothing about sockets, and needs to be passed a domain name, dns type and dns class which we are interested in. It returns a vector of DNSResourceRecord objects, ready for writing either into an answer packet, or for internal use.</p><p>After checking if the query is for any of the hardcoded domains (localhost, version.bind, id.server), the query is passed to SyncRes::doResolve, together with two vital parameters: the <code class="literal">depth</code> and <code class="literal">beenthere</code> set. As the word <span class="command"><strong>recursor</strong></span> implies, we will need to recurse for answers. The <span class="command"><strong>depth</strong></span> parameter documents how deep we've recursed already.</p><p>The <code class="literal">beenthere</code> set prevents loops. At each step, when a nameserver is queried, it is added to the <code class="literal">beenthere</code> set. No nameserver in the set will ever be queried again for the same question in the recursion process - we know for a fact it won't help us further. This prevents the process from getting stuck in loops.</p><p>SyncRes::doResolve first checks if there is a CNAME in cache, using SyncRes::doCNAMECacheCheck, for the domain name and type queried and if so, changes the query (which is passed by reference) to the domain the CNAME points to. This is the cause of many DNS problems, a CNAME record really means <span class="command"><strong>start over with this query</strong></span>.</p><p>This is followed by a call do SyncRes::doCacheCheck, which consults the cache for a straight answer to the question (as possibly rerouted by a CNAME). This function also consults the so called negative cache, but we won't go into that just yet.</p><p>If this function finds the correct answer, and the answer hasn't expired yet, it gets returned and we are (almost) done. This happens in 80 to 90% of all queries. Which is good, as what follows is a lot of work.</p><p>To recap:
	  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
		beginResolve() - entry point, does checks for hardcoded domains
	      </p></li><li class="listitem"><p>
		doResolve() - start of recursion process, gets passed <code class="literal">depth</code> of 0 and empty <code class="literal">beenthere</code> set
	      </p></li><li class="listitem"><p>
		doCNAMECacheCheck() - check if there is a CNAME in cache which would reroute the query
	      </p></li><li class="listitem"><p>
		doCacheCheck() - see if cache contains straight answer to possibly rerouted query.
	      </p></li></ol></div><p>
	</p><p>If the data we were queried for was in the cache, we are almost done. One final step, which might as well be optional as nobody benefits from it, is SyncRes::addCruft. This function does additional processing, which means that if the query was for the MX record of a domain, we also add the IP address of the mail exchanger.</p></div><div class="sect2" title="8.7. The non-cached case"><div class="titlepage"><div><div><h3 class="title"><a id="id411069"></a>8.7. The non-cached case</h3></div></div></div><p>This is where things get interesting, because we start out with a nearly empty cache and have to go out to the net to get answers to fill it.</p><p>The way DNS works, if you don't know the answer to a question, you find somebody who does. Initially you have no other place to go than the root servers. This is embodied in the SyncRes::getBestNSNamesFromCache method, which gets passed the domain we are interested in, as well as the <code class="literal">depth</code> and <code class="literal">beenthere</code> parameters mentioned earlier.</p><p>From now on, assume our query will be for <span class="command"><strong><code class="literal">www.powerdns.com.</code></strong></span>. SyncRes::getBestNSNamesFromCache will first check if there are NS records in cache for <code class="literal"><span class="command"><strong>www.powerdns.com.</strong></span></code>, but there won't be. It then checks <code class="literal">powerdns.com. NS</code>, and while these records do exist on the internet, the recursor doesn't know about them yet. So, we go on to check the cache for <code class="literal"><span class="command"><strong>com. NS</strong></span></code>, for which the same holds. Finally we end up checking for <code class="literal"><span class="command"><strong>. NS</strong></span></code>, and these we do know about: they are the root servers and were loaded into PowerDNS on startup.</p><p>So, SyncRes::getBestNSNamesFromCache fills out a set with the <span class="command"><strong>names</strong></span> of nameservers it knows about for the <span class="command"><strong><code class="literal">.</code></strong></span> zone.</p><p>This set, together with the original query <span class="command"><strong><code class="literal">www.powerdns.com</code></strong></span> gets passed to SyncRes::doResolveAt. This function can't yet go to work immediately though, it only knows the names of nameservers it can try. This is like asking for directions and instead of hearing <span class="command"><strong>take the third right</strong></span> you are told <span class="command"><strong>go to 123 Fifth Avenue, and take a right</strong></span> - the answer doesn't help you further unless you know where 123 Fifth Avenue is.</p><p>SyncRes::doResolveAt first shuffles the nameservers both randomly and on performance order. If it knows a nameserver was fast in the past, it will get queried first. More about this later.</p><p>Ok, here is the part where things get a bit scary. How does SyncRes::doResolveAt find the IP address of a nameserver? Well, by calling SyncRes::getAs (<span class="command"><strong>get A records</strong></span>), which in turn calls.. SyncRes::doResolve. Hang on! That's where we came from! Massive potential for loops here. Well, it turns out that for any domain which can be resolved, this loop terminates. We do pass the <code class="literal">beenthere</code> set again, which makes sure we don't keep on asking the same questions to the same nameservers.</p><p>Ok, SyncRes::getAs will give us the IP addresses of the chosen root-server, because these IP addresses were loaded on startup. We then ask these IP addresses (nameservers can have several) for its best answer for <span class="command"><strong><code class="literal">www.powerdns.com.</code></strong></span>. This is done using the LWRes class and specifically LWRes::asyncresolve, which gets passed domain name, type and IP address. This function interacts with MTasker and MPlexer above in ways which needn't concern us now. When it returns, the LWRes object contains the best answers the queried server had for our domain, which in this case means it tells us about the nameservers of <code class="literal">com.</code>, and their IP addresses.</p><p>All the relevant answers it gives are stored in the cache (or actually, merged), after which SyncRes::doResolveAt (which we are still in) evaluates what to do now.</p><p>There are 6 options:
	  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
		The final answer is in, we are done, return to SyncRes::doResolve and SyncRes::beginResolve
	      </p></li><li class="listitem"><p>
		The nameserver we queried tells us the domain we asked for authoritatively does not exist. In case of the root-servers, this happens when we query for <span class="emphasis"><em><code class="literal">www.powerdns.kom.</code></em></span> for example, there is no <span class="emphasis"><em><code class="literal">kom.</code></em></span>. Return to SyncRes::beginResolve, we are done.
	      </p></li><li class="listitem"><p>
		A lesser form - it tells us it is authoritative for the query we asked about, but there is no record matching our type. This happens when querying for the IPv6 address of a host which only has an IPv4 address. Return to SyncRes::beginResolve, we are done.
	      </p></li><li class="listitem"><p>
		The nameserver passed us a CNAME to another domain, and we need to reroute. Go to SyncRes::doResolve for the new domain.
	      </p></li><li class="listitem"><p>
		The namserver did not know about the domain, but does know who does, a <span class="emphasis"><em>referral</em></span>. Stay within doResolveAt and loop to these new nameservers.
	      </p></li><li class="listitem"><p>
		The nameserver replied saying <span class="emphasis"><em>no idea</em></span>. This is called a <span class="emphasis"><em>lame delegation</em></span>. Stay within SyncRes::doResolveAt and try the other nameservers we have for this domain.
	      </p></li></ol></div><p>
	</p><p>When not redirected using a CNAME, this function will loop until it has exhausted all nameservers and all their IP addresses. DNS is surprisingly resilient that there is often only a single non-broken nameserver left to answer queries, and we need to be prepared for that.</p><p>This is the whole DNS algorithm in PowerDNS, all in less than 700 lines of code. It contains a lot of tricky bits though, related to the cache.</p></div><div class="sect2" title="8.8. Some of the things we glossed over"><div class="titlepage"><div><div><h3 class="title"><a id="id411340"></a>8.8. Some of the things we glossed over</h3></div></div></div><p>Whenever a packet is sent to a remote nameserver, the response time is stored in the SyncRes::s_nsSpeeds map, using an exponentially weighted moving average. This EWMA averages out different response times, and also makes them decrease over time. This means that a nameserver that hasn't been queried recently gradually becomes <span class="command"><strong>faster</strong></span> in the eyes of PowerDNS, giving it a chance again.</p><p>A timeout is accounted as a 1s response time, which should take that server out of the running for a while.</p><p>Furthermore, queries are throttled. This means that each query to a nameserver that has failed is accounted in the <code class="literal">s_throttle</code> object. Before performing a new query, the query and the nameserver are looked up via shouldThrottle. If so, the query is assumed to have failed without even being performed. This saves a lot of network traffic and makes PowerDNS quick to respond to lame servers.</p><p>It also offers a modicum of protection against birthday attack powered spoofing attempts, as PowerDNS will not innundate a broken server with queries.</p><p>The negative query cache we mentioned earlier caches the cases 2 and 3 in the enumeration above. This data needs to be stored separately, as it represents <span class="command"><strong>non-data</strong></span>. Each negcache query entry is the name of the SOA record that was presented with the evidence of non-existance. This SOA record is then retrieved from the regular cache, but with the TTL that originally came with the NXDOMAIN (case 2) or NXRRSET (case 3).</p></div><div class="sect2" title="8.9. The Recursor Cache"><div class="titlepage"><div><div><h3 class="title"><a id="id411394"></a>8.9. The Recursor Cache</h3></div></div></div><p>As mentioned before, the cache stores partial packets. It also stores not the <span class="command"><strong>Time To Live</strong></span> of records, but in fact the <span class="command"><strong>Time To Die</strong></span>. If the cache contains data, but it is expired, that data should not be deemed present. This bit of PowerDNS has proven tricky, leading to deadlocks in the past.</p><p>There are some other very tricky things to deal with. For example, through a process called <span class="command"><strong>more details</strong></span>, a domain might have more nameservers than listed in its parent zone. So, there might only be two nameservers for <code class="literal"><span class="command"><strong>powerdns.com.</strong></span></code> in the <span class="command"><strong><code class="literal">com.</code></strong></span> zone, but the <span class="command"><strong><code class="literal">powerdns.com</code></strong></span> zone might list more.</p><p>This means that the cache should not, when talking to the <span class="command"><strong><code class="literal">com.</code></strong></span> servers later on, overwrite these four nameservers with only the two copies the <span class="command"><strong><code class="literal">com.</code></strong></span> servers pass us.</p><p>However, in other cases (like for example for SOA and CNAME records), new data should overwrite old data.</p><p>Note that PowerDNS deviates from RFC 2181 (section 5.4.1) in this respect.</p></div><div class="sect2" title="8.10. Some small things"><div class="titlepage"><div><div><h3 class="title"><a id="id411488"></a>8.10. Some small things</h3></div></div></div><p>The server-side part of PowerDNS (<code class="literal">pdns_recursor.cc</code>), which listens to queries by end-users, is fully IPv6 capable using the ComboAddress class. This class is in fact a union of a <code class="literal">struct sockaddr_in</code> and a <code class="literal">struct sockaddr_in6</code>. As long as the <code class="literal">sin_family</code> (or <code class="literal">sin6_family</code>) and <code class="literal">sin_port</code> members are in the same place, this works just fine, allowing us to pass a ComboAddress*, cast to a <code class="literal">sockaddr*</code> to the socket functions. For convenience, the ComboAddress also offers a length() method which can be used to indicate the length - either sizeof(sockaddr_in) or sizeof(sockaddr_in6).</p><p>Access to the recursor is governed through the NetmaskGroup class, which internally contains Netmaks, which in turn contain a ComboAddress.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="recursor-scripting.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="built-in-recursor.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="replication.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7. Scripting </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 17. Master/Slave operation &amp; replication</td></tr></table></div></body></html>
